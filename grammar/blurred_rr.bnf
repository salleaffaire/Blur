# Blurred Programming Language Grammar (BNF)
# ----------------------------------------------------------------------------------------

# Program structure
> <program>
/ ''

# Top level 
<program> ::= <decdef-list>

# Right-Recursion version
<decdef-list> ::= <decdef> <decdef-rest>
<decdef-rest> ::= <decdef> <decdef-rest> | ''

<decdef> ::= <data-definition> | <fun-declaration> | <struct-declaration>

# Struct
# ----------------------------------------------------------------------------------------
<struct-declaration> ::=  struct name { <decdef-list> }

# Var
# ----------------------------------------------------------------------------------------
<data-definition> ::= var <type-specifier> name ; |
                      if ( <simple-expression> ) <data-definition>

<type-specifier> ::= <base-type> <array-definition> |
                     <base-type>

<array-definition> ::= <array-definition> [ numeral ] |
                       [ numeral ]

<base-type> ::= bit |
                list { <type-specifier> } |
                void |
                name

# Functions 
<fun-declaration> ::= func <type-specifier> name ( <params> ) { <statement> }

<params> ::= <param-list> | ''

<param-list> ::= <param-list> , <param> | <param>

<param> ::= <type-specifier> name

# Statements
<statement> ::= <expression-statement> |   
                <compound-statement> |
                <if-statement> |
                <return-statement> |
                <for-statement> |
                <while-statement> |
                <return-statement> |
                <break-statement> |
                <data-definition> |
                ''

<expression-statement> ::= <expression> ; | ;

<compound-statement> ::= { <statement-list> }

<statement-list> ::= <statement-list> <statement> | ''

<if-statement> ::= if ( <expression> ) <statement> |
                   if ( <expression> ) <statement> else <statement>

<return-statement> ::= return ; |
                       return <expression> ;

<break-statement> ::= break ;

<while-statement> ::= while ( <expression> ) statement |
                      foreach ( <mutable> in name )

<for-statement> ::= for ( <mutable> = <simple-expression> ; <simple-expression> ; <simple-expression> ) <statement>

# Expressions
<expression> ::= <mutable> = <simple-expression> | 
                 <simple-expression>

<simple-expression> ::= <simple-expression> <bin-operator-1> <simple-term> |
                        <simple-term>

<simple-term> ::=  <simple-term> <bin-operator-2> <factor> |
                   <factor>

<factor> ::=  <call> |
             <un-operator> <simple-expression> |
             <constant> |
             ( <simple-expression> )

# Weak operators
<bin-operator-1> ::= + | -


#Strong operators
<bin-operator-2> ::= * | /

<un-operator> ::= + | - | ! | ~

<call> ::= name ( <args> )

<args> ::= <arg-list> | ''

<arg-list> ::= <arg-list> , <arg> | <arg>

<arg> ::= <simple-expression>

<constant> ::= numeral | 
               literal |
               true |
               false

<mutable> ::= name