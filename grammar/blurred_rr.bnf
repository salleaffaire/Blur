# Blurred Programming Language Grammar (BNF)

# Program structure
> <program>
/ ''

# Top level 
<program> ::= <declaration-list>

# Left-Recursion <declaration-list> production rule 
# <declaration-list> ::= <declaration-list> <declaration> |
#                        <declaration>

# Right-Recursion version
<declaration-list> ::= <declaration> <declaration-rest>
<declaration-rest> ::= <declaration> <declaration-rest> | ''

<declaration> ::= <data-declaration> | <fun-declaration>


# Data declarations
# ----------------------------------------------------------------------------------------

<data-declaration-list> ::= <data-declaration> <data-declaration-rest>

<data-declaration-rest> ::= <data-declaration> <data-declaration-rest> | ''

#Vars
<data-declaration> ::= <type-specifier> name ; |
                       struct name { <data-declaration-list> } ; |
                       <data-declaration-cond>

<data-declaration-cond> ::= if ( <simple-expression> ) <data-declaration>

<type-specifier> ::= <base-type> <array-declaration> |
                     <base-type>

<array-declaration> ::= <array-declaration> [ numeral ] |
                        [ numeral ]

<base-type> ::= bit |
                list { <type-specifier> } |
                void |
                name

# Functions 
<fun-declaration> ::= <type-specifier> name ( <params> ) { <statement> }

<params> := <param-list> | ''

<param-list> :: <param-list> , <param> | <param>

<param> ::= <type-specifier> name

# Statements
<statement> ::= <expression-statement> |   
                <compound-statement> |
                <if-statement> |
                <return-statement> |
                <for-statement> |
                <while-statement> |
                <return-statement> |
                <break-statement>

<expression-statement> ::= <expression> ; | ;

<compound-statement> ::= { <statement-list> }

<statement-list> ::= <statement-list> <statement> | ''

<if-statement> ::= if ( <expression> ) <statement> |
                   if ( <expression> ) <statement> else <statement>

<return-statement> ::= return ; |
                       return <expression> ;

<break-statement> ::= break ;

<while-statement> ::= while ( <expression> ) statement |
                      foreach ( <mutable> in name )

# Expressions
<expression> ::= <mutable> = <simple-expression>

<simple-expression> ::= <simple-expression> <bin-operator-1> <simple-term> |
                        <simple-term>

<simple-term> ::=  <simple-term> <bin-operator-2> <factor> |
                   <factor>

<factor> := ( <simple-expression> ) |
             <un-operator> <simple-expression> |
             <constant> |
             <call>

# Weak operators
<bin-operator-1> ::= + | -    
                     

#Strong operators
<bin-operator-2> ::= * | /

<un-operator> := + | - | ! | ~   

<call> ::= name ( <args> )

<args> ::= <arg-list> | ''

<arg-list> ::= <arg-list> , <arg> | <arg>

#<arg> ::= <simple-expression>

<constant> ::= numeral | 
               literal |
               true |
               false

